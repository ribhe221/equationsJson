{
    "version": "1.0.0",
    "lastUpdated": "2025-10-24",
    "problems": [
        {
            "id": "utils-get-random",
            "title": "Implement Random Number Generator",
            "difficulty": "easy",
            "category": "algorithms",
            "description": "Create a utility method called `getRandom` in the Utils class that generates and returns a random integer within a specified range. The method should accept two parameters: a minimum value (min) and a maximum value (max), both inclusive. Your implementation should use Java's built-in Math.random() method, which returns a double value between 0.0 (inclusive) and 1.0 (exclusive). You'll need to properly scale and shift this value to fit within the desired integer range. The solution should handle any valid integer range and consistently produce values within the specified bounds.",
            "questionCode": "",
            "solutionCode": "public class Utils {\n    public static int getRandom(int min, int max) {\n        return (int) (Math.random() * (max - min + 1)) + min;\n    }\n    \n    public static void main(String[] args) {\n        int result = getRandom(1, 10);\n        System.out.println(\"Random number between 1 and 10: \" + result);\n        \n        // Test that result is in valid range\n        if (result >= 1 && result <= 10) {\n            System.out.println(\"Valid range: true\");\n        } else {\n            System.out.println(\"Valid range: false\");\n        }\n    }\n}",
            "expectedOutput": "Random number between 1 and 10: 5\nValid range: true",
            "hints": [
                "Use Math.random() which returns a double between 0.0 and 1.0",
                "Scale the random value by multiplying by (max - min + 1)",
                "Add min to shift the range to start at min",
                "Cast the result to int to get a whole number"
            ],
            "tags": [
                "easy",
                "algorithms"
            ],
            "bestCaseComplexity": "O(1)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "person-compare-to",
            "title": "Implement Person Comparison",
            "difficulty": "easy",
            "category": "object-oriented",
            "description": "Design and implement a Person class that implements the Comparable interface to enable natural ordering of Person objects. Your implementation should define a compareTo method that first compares persons alphabetically by their name field. If two persons have identical names, the comparison should then be based on their age, with younger persons ordered before older ones. This is a common pattern in Java for creating sortable objects that can be used with Collections.sort() or TreeSet. The class should have private fields for name (String) and age (int), along with appropriate getter methods and a constructor. Your compareTo method must return a negative integer, zero, or positive integer when the current object is less than, equal to, or greater than the specified object.",
            "questionCode": "",
            "solutionCode": "public class Person implements Comparable<Person> {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public int compareTo(Person o) {\n        int result = this.name.compareTo(o.name);\n        if (result == 0) {\n            result = Integer.compare(age, o.age);\n        }\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Person p1 = new Person(\"Alice\", 25);\n        Person p2 = new Person(\"Bob\", 30);\n        Person p3 = new Person(\"Alice\", 20);\n        \n        System.out.println(\"Alice(25) vs Bob(30): \" + p1.compareTo(p2));\n        System.out.println(\"Bob(30) vs Alice(25): \" + p2.compareTo(p1));\n        System.out.println(\"Alice(25) vs Alice(20): \" + p1.compareTo(p3));\n    }\n}",
            "expectedOutput": "Alice(25) vs Bob(30): -1\nBob(30) vs Alice(25): 1\nAlice(25) vs Alice(20): 5",
            "hints": [
                "Use String.compareTo() to compare names",
                "If names are equal (result == 0), compare ages",
                "Use Integer.compare() to compare age values",
                "Return the comparison result"
            ],
            "tags": [
                "easy",
                "object-oriented"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "planet-temperature",
            "title": "Planet Temperature Display",
            "difficulty": "medium",
            "category": "object-oriented",
            "description": "Create a Planet class that models celestial bodies with their associated temperature data. The class should encapsulate two private fields: a double value representing the planet's average temperature (t) and a String containing the planet's name. Implement a constructor that accepts these two parameters and properly initializes the instance variables. Additionally, override the toString method to provide a formatted string representation of the planet that displays both the name and temperature in a human-readable format (name : temperatureC°). Include appropriate getter methods for accessing the private fields. This exercise demonstrates fundamental object-oriented programming concepts including encapsulation, constructors, and the proper use of the toString method for object representation.",
            "questionCode": "",
            "solutionCode": "public class Planet {\n    private double t;\n    private String name;\n\n    public Planet(double t, String name) {\n        this.name = name;\n        this.t = t;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getT() {\n        return t;\n    }\n    \n    public String toString() {\n        return name + \" : \" + t + \"C°\";\n    }\n    \n    public static void main(String[] args) {\n        Planet earth = new Planet(15.0, \"Earth\");\n        Planet mars = new Planet(-63.0, \"Mars\");\n        \n        System.out.println(earth.toString());\n        System.out.println(mars.toString());\n        System.out.println(\"Earth temp: \" + earth.getT());\n    }\n}",
            "expectedOutput": "Earth : 15.0C°\nMars : -63.0C°\nEarth temp: 15.0",
            "hints": [
                "In the constructor, assign parameters to instance variables using this keyword",
                "The toString method should concatenate name, \" : \", temperature, and \"C°\"",
                "Use the + operator for string concatenation",
                "Remember to return the formatted string"
            ],
            "tags": [
                "medium",
                "object-oriented"
            ],
            "bestCaseComplexity": "O(1)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "planets-collection",
            "title": "Planet Collection Analysis",
            "difficulty": "medium",
            "category": "collections",
            "description": "Develop a Planets class that manages a collection of Planet objects using an ArrayList. This class should provide functionality for analyzing the collection of planets through two key methods. First, implement a getAverageTemperature method that iterates through all planets in the collection and calculates their mean temperature by summing all temperature values and dividing by the count. Second, create a getFindResult method that searches through the collection to locate a planet with a specific temperature value, returning the index position (zero-based) of the first matching planet, or -1 if no planet with that temperature exists. This problem demonstrates working with collections, performing aggregate calculations, and implementing search algorithms. You'll also need to implement an add method to populate the collection with Planet objects.",
            "questionCode": "",
            "solutionCode": "import java.util.ArrayList;\n\npublic class Planet {\n    private double t;\n    private String name;\n\n    public Planet(double t, String name) {\n        this.name = name;\n        this.t = t;\n    }\n\n    public double getT() {\n        return t;\n    }\n}\n\npublic class Planets {\n    private ArrayList<Planet> alPlanets = new ArrayList<>();\n    \n    public void add(Planet p) {\n        alPlanets.add(p);\n    }\n\n    public double getAverageTemperature() {\n        double sum = 0;\n        for (Planet p : alPlanets) {\n            sum += p.getT();\n        }\n        return sum / alPlanets.size();\n    }\n\n    public int getFindResult(double t) {\n        for (int i = 0; i < alPlanets.size(); i++) {\n            Planet p = alPlanets.get(i);\n            if (t == p.getT()) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Planets planets = new Planets();\n        planets.add(new Planet(15.0, \"Earth\"));\n        planets.add(new Planet(-63.0, \"Mars\"));\n        planets.add(new Planet(464.0, \"Venus\"));\n        \n        System.out.println(\"Average temperature: \" + planets.getAverageTemperature());\n        System.out.println(\"Index of planet with temp 15.0: \" + planets.getFindResult(15.0));\n        System.out.println(\"Index of planet with temp 100.0: \" + planets.getFindResult(100.0));\n    }\n}",
            "expectedOutput": "Average temperature: 138.66666666666666\nIndex of planet with temp 15.0: 0\nIndex of planet with temp 100.0: -1",
            "hints": [
                "For average: use a for-each loop to sum all temperatures",
                "Divide the sum by the size of the ArrayList",
                "For find: use a regular for loop with index",
                "Compare each planet's temperature with the target temperature",
                "Return the index when found, or -1 if the loop completes without finding"
            ],
            "tags": [
                "medium",
                "collections"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "shape-inheritance",
            "title": "Shape Inheritance System",
            "difficulty": "hard",
            "category": "object-oriented",
            "description": "Design and implement a complete inheritance hierarchy for geometric shapes using abstract classes and polymorphism. Create an abstract Shape base class that defines common properties (x and y coordinates, color) and an abstract method getArea() that must be implemented by all subclasses. The Shape class should also include a concrete method changeColor() that randomly assigns one of three colors (Red, Green, or Blue) to the shape using the Utils.getRandom method. Then, create two concrete subclasses: Circle (with a radius field) and Square (with a sideLength field). Each subclass must properly call the superclass constructor using super() and implement the getArea() method with the appropriate mathematical formula (π*r² for circles, side² for squares). This exercise demonstrates key object-oriented concepts including abstraction, inheritance, polymorphism, and the proper use of constructors in a class hierarchy.",
            "questionCode": "",
            "solutionCode": "public class Utils {\n    public static int getRandom(int min, int max) {\n        return (int) (Math.random() * (max - min + 1)) + min;\n    }\n}\n\npublic abstract class Shape {\n    protected int x;\n    protected int y;\n    protected String color;\n\n    public Shape(int x, int y, String color) {\n        this.x = x;\n        this.y = y;\n        this.color = color;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public abstract double getArea();\n    \n    public void changeColor() {\n        int colorValue = Utils.getRandom(0, 2);\n        if (colorValue == 0) color = \"Red\";\n        else if (colorValue == 1) color = \"Green\";\n        else color = \"Blue\";\n    }\n}\n\npublic class Circle extends Shape {\n    private int radius;\n\n    public Circle(int x, int y, String color, int radius) {\n        super(x, y, color);\n        this.radius = radius;\n    }\n\n    @Override\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Square extends Shape {\n    private int sideLength;\n\n    public Square(int x, int y, String color, int sideLength) {\n        super(x, y, color);\n        this.sideLength = sideLength;\n    }\n\n    @Override\n    public double getArea() {\n        return sideLength * sideLength;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Circle circle = new Circle(10, 20, \"Red\", 5);\n        Square square = new Square(30, 40, \"Blue\", 10);\n        \n        System.out.println(\"Circle color: \" + circle.getColor());\n        System.out.println(\"Circle area: \" + circle.getArea());\n        System.out.println(\"Square color: \" + square.getColor());\n        System.out.println(\"Square area: \" + square.getArea());\n        \n        circle.changeColor();\n        System.out.println(\"Circle new color: \" + circle.getColor());\n    }\n}",
            "expectedOutput": "Circle color: Red\nCircle area: 78.53981633974483\nSquare color: Blue\nSquare area: 100.0\nCircle new color: Green",
            "hints": [
                "Use the \"abstract\" keyword before the class declaration for Shape",
                "Declare an abstract method with no body: public abstract double getArea();",
                "Use \"extends Shape\" in Circle and Square class declarations",
                "Call super(x, y, color) as the first line in subclass constructors",
                "Override getArea() in both subclasses with @Override annotation",
                "Circle area formula: Math.PI * radius * radius",
                "Square area formula: sideLength * sideLength"
            ],
            "tags": [
                "hard",
                "object-oriented"
            ],
            "bestCaseComplexity": "O(1)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "person-to-string",
            "title": "Person Contact Information",
            "difficulty": "medium",
            "category": "object-oriented",
            "description": "Create a comprehensive Person class that stores and formats contact information for individuals. The class should maintain three private fields: name, email address (mail), and telephone number (telNum). Implement a constructor that properly initializes all three fields in the correct order, and create getter methods for accessing each field. Most importantly, override the toString() method to return a formatted string that concatenates all three pieces of information separated by semicolons (name;mail;telNum). Additionally, implement the Comparable interface with a compareTo method that sorts Person objects alphabetically by name. This exercise combines multiple object-oriented concepts including encapsulation, constructor design, method overriding, and interface implementation for creating sortable, displayable objects.",
            "questionCode": "",
            "solutionCode": "public class Person implements Comparable<Person> {\n    private String telNum;\n    private String mail;\n    private String name;\n\n    public Person(String name, String mail, String telNum) {\n        this.name = name;\n        this.mail = mail; \n        this.telNum = telNum;\n    }\n\n    public String getTelNum() {\n        return telNum;\n    }\n\n    public String getMail() {\n        return mail;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public int compareTo(Person o) {\n        return this.name.compareTo(o.name);\n    }\n    \n    @Override\n    public String toString() {\n        return name + \";\" + mail + \";\" + telNum;\n    }\n    \n    public static void main(String[] args) {\n        Person p1 = new Person(\"Alice\", \"alice@email.com\", \"555-1234\");\n        Person p2 = new Person(\"Bob\", \"bob@email.com\", \"555-5678\");\n        \n        System.out.println(p1.toString());\n        System.out.println(p2.toString());\n        System.out.println(\"Name: \" + p1.getName());\n    }\n}",
            "expectedOutput": "Alice;alice@email.com;555-1234\nBob;bob@email.com;555-5678\nName: Alice",
            "hints": [
                "In the constructor, assign each parameter to the corresponding instance variable",
                "Use the this keyword to distinguish instance variables from parameters",
                "In toString, concatenate name, \";\", mail, \";\", and telNum",
                "Use the + operator for string concatenation"
            ],
            "tags": [
                "medium",
                "object-oriented"
            ],
            "bestCaseComplexity": "O(1)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "array-sum",
            "title": "Array Sum Calculator",
            "difficulty": "easy",
            "category": "algorithms",
            "description": "Implement a static utility method called calculateSum that computes the sum of all elements in an integer array. The method should accept an array of integers as its parameter and return the total sum as an integer value. Your solution must handle arrays of any length, including edge cases such as empty arrays (which should return 0). Use an enhanced for loop (for-each loop) to iterate through the array elements efficiently. This is a fundamental array manipulation problem that tests your understanding of array traversal, accumulator patterns, and basic arithmetic operations in Java.",
            "questionCode": "",
            "solutionCode": "public class ArrayUtils {\n    public static int calculateSum(int[] numbers) {\n        int sum = 0;\n        for (int num : numbers) {\n            sum += num;\n        }\n        return sum;\n    }\n    \n    public static void main(String[] args) {\n        int[] arr1 = {1, 2, 3, 4, 5};\n        int[] arr2 = {10, 20, 30};\n        int[] arr3 = {};\n        \n        System.out.println(\"Sum of arr1: \" + calculateSum(arr1));\n        System.out.println(\"Sum of arr2: \" + calculateSum(arr2));\n        System.out.println(\"Sum of arr3: \" + calculateSum(arr3));\n    }\n}",
            "expectedOutput": "Sum of arr1: 15\nSum of arr2: 60\nSum of arr3: 0",
            "hints": [
                "Initialize a sum variable to 0",
                "Use a for-each loop to iterate through the array",
                "Add each element to the sum",
                "Return the final sum"
            ],
            "tags": [
                "easy",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "string-reverse",
            "title": "String Reverser",
            "difficulty": "easy",
            "category": "algorithms",
            "description": "Create a method called reverseString that takes a String parameter and returns a new String containing the characters in reverse order. Your implementation should iterate through the original string from the last character to the first, building the reversed string character by character. Use a StringBuilder for efficient string construction, as it provides better performance than string concatenation when building strings in a loop. The method should handle strings of any length, including single-character strings and empty strings. This exercise demonstrates string manipulation techniques, loop control with reverse iteration, and the proper use of StringBuilder for mutable string operations.",
            "questionCode": "",
            "solutionCode": "public class StringUtils {\n    public static String reverseString(String input) {\n        StringBuilder reversed = new StringBuilder();\n        for (int i = input.length() - 1; i >= 0; i--) {\n            reversed.append(input.charAt(i));\n        }\n        return reversed.toString();\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Reversed 'hello': \" + reverseString(\"hello\"));\n        System.out.println(\"Reversed 'Java': \" + reverseString(\"Java\"));\n        System.out.println(\"Reversed 'a': \" + reverseString(\"a\"));\n    }\n}",
            "expectedOutput": "Reversed 'hello': olleh\nReversed 'Java': avaJ\nReversed 'a': a",
            "hints": [
                "Use StringBuilder to build the reversed string",
                "Loop from the end of the string to the beginning",
                "Append each character to the StringBuilder",
                "Convert StringBuilder to String and return"
            ],
            "tags": [
                "easy",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(n)"
        },
        {
            "id": "find-max",
            "title": "Find Maximum Value",
            "difficulty": "easy",
            "category": "algorithms",
            "description": "Write a method named findMax that identifies and returns the largest value in an integer array. The method should initialize a variable to hold the maximum value (starting with the first element), then compare each subsequent element against the current maximum, updating it whenever a larger value is found. Your solution must correctly handle arrays containing negative numbers, single-element arrays, and arrays with duplicate maximum values. This is a classic array traversal problem that introduces the concept of tracking an optimal value through iteration. The algorithm should make exactly one pass through the array for optimal efficiency.",
            "questionCode": "",
            "solutionCode": "public class ArrayUtils {\n    public static int findMax(int[] numbers) {\n        int max = numbers[0];\n        for (int i = 1; i < numbers.length; i++) {\n            if (numbers[i] > max) {\n                max = numbers[i];\n            }\n        }\n        return max;\n    }\n    \n    public static void main(String[] args) {\n        int[] arr1 = {3, 7, 2, 9, 1};\n        int[] arr2 = {-5, -2, -10, -1};\n        int[] arr3 = {42};\n        \n        System.out.println(\"Max of arr1: \" + findMax(arr1));\n        System.out.println(\"Max of arr2: \" + findMax(arr2));\n        System.out.println(\"Max of arr3: \" + findMax(arr3));\n    }\n}",
            "expectedOutput": "Max of arr1: 9\nMax of arr2: -1\nMax of arr3: 42",
            "hints": [
                "Initialize max to the first element of the array",
                "Loop through the rest of the array starting at index 1",
                "Compare each element with the current max",
                "Update max if a larger value is found"
            ],
            "tags": [
                "easy",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "count-vowels",
            "title": "Count Vowels in String",
            "difficulty": "easy",
            "category": "algorithms",
            "description": "Develop a method called countVowels that analyzes a text string and returns the total count of vowel characters (a, e, i, o, u) it contains. Your implementation should be case-insensitive, meaning it should count both uppercase and lowercase vowels. Iterate through each character in the input string and check whether it appears in a predefined string containing all vowel characters (both cases). Use the String.indexOf() method to perform this check efficiently - it returns -1 if the character is not found, and a non-negative index if it is found. Maintain a counter that increments each time a vowel is encountered, and return this count at the end. This problem combines string traversal, character checking, and conditional counting.",
            "questionCode": "",
            "solutionCode": "public class StringUtils {\n    public static int countVowels(String text) {\n        int count = 0;\n        String vowels = \"aeiouAEIOU\";\n        for (int i = 0; i < text.length(); i++) {\n            if (vowels.indexOf(text.charAt(i)) != -1) {\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Vowels in 'hello': \" + countVowels(\"hello\"));\n        System.out.println(\"Vowels in 'Java Programming': \" + countVowels(\"Java Programming\"));\n        System.out.println(\"Vowels in 'xyz': \" + countVowels(\"xyz\"));\n    }\n}",
            "expectedOutput": "Vowels in 'hello': 2\nVowels in 'Java Programming': 5\nVowels in 'xyz': 0",
            "hints": [
                "Create a string containing all vowels (both uppercase and lowercase)",
                "Initialize a counter to 0",
                "Loop through each character in the input string",
                "Check if the character is in the vowels string using indexOf()",
                "Increment counter if it's a vowel"
            ],
            "tags": [
                "easy",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "factorial",
            "title": "Calculate Factorial",
            "difficulty": "medium",
            "category": "algorithms",
            "description": "Implement a method that calculates the factorial of a non-negative integer. The factorial of a number n (denoted as n!) is the product of all positive integers less than or equal to n. For example, 5! = 5 × 4 × 3 × 2 × 1 = 120. By mathematical convention, 0! = 1 and 1! = 1. Your method should handle these base cases explicitly before computing the factorial iteratively using a loop. Use the long data type for the result to accommodate larger factorial values, as factorials grow very rapidly and quickly exceed the range of int. The iterative approach is preferred over recursion for this problem as it avoids potential stack overflow issues for larger inputs.",
            "questionCode": "",
            "solutionCode": "public class MathUtils {\n    public static long factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Factorial of 5: \" + factorial(5));\n        System.out.println(\"Factorial of 0: \" + factorial(0));\n        System.out.println(\"Factorial of 7: \" + factorial(7));\n    }\n}",
            "expectedOutput": "Factorial of 5: 120\nFactorial of 0: 1\nFactorial of 7: 5040",
            "hints": [
                "Handle the base case: factorial of 0 and 1 is 1",
                "Initialize result to 1",
                "Loop from 2 to n and multiply result by each number",
                "Use long type to handle larger factorials"
            ],
            "tags": [
                "medium",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "is-palindrome",
            "title": "Check Palindrome",
            "difficulty": "medium",
            "category": "algorithms",
            "description": "Create a method that determines whether a given string is a palindrome - a word, phrase, or sequence that reads the same backward as forward (like 'racecar' or 'level'). Implement an efficient two-pointer approach: initialize one pointer at the beginning of the string and another at the end, then move them toward each other, comparing characters at each step. If any pair of characters doesn't match, the string is not a palindrome and you should immediately return false. If the pointers meet or cross without finding a mismatch, the string is a palindrome. This algorithm is optimal because it only requires a single pass through half of the string, making it more efficient than creating a reversed copy for comparison.",
            "questionCode": "",
            "solutionCode": "public class StringUtils {\n    public static boolean isPalindrome(String text) {\n        int left = 0;\n        int right = text.length() - 1;\n        while (left < right) {\n            if (text.charAt(left) != text.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Is 'racecar' palindrome: \" + isPalindrome(\"racecar\"));\n        System.out.println(\"Is 'hello' palindrome: \" + isPalindrome(\"hello\"));\n        System.out.println(\"Is 'level' palindrome: \" + isPalindrome(\"level\"));\n    }\n}",
            "expectedOutput": "Is 'racecar' palindrome: true\nIs 'hello' palindrome: false\nIs 'level' palindrome: true",
            "hints": [
                "Use two pointers: one at the start and one at the end",
                "Compare characters at both pointers",
                "If they don't match, return false",
                "Move pointers towards the center and continue",
                "If all characters match, return true"
            ],
            "tags": [
                "medium",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "fibonacci",
            "title": "Fibonacci Sequence",
            "difficulty": "medium",
            "category": "algorithms",
            "description": "Implement a method that calculates the nth number in the Fibonacci sequence using an iterative approach. The Fibonacci sequence is a series where each number is the sum of the two preceding ones: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on. The sequence starts with F(0) = 0 and F(1) = 1. Your method should handle these base cases explicitly, then use a loop to iteratively calculate subsequent Fibonacci numbers by maintaining two variables that track the previous two values in the sequence. This iterative approach is much more efficient than recursive solutions, achieving O(n) time complexity and O(1) space complexity. The method should work correctly for any non-negative integer input.",
            "questionCode": "",
            "solutionCode": "public class MathUtils {\n    public static int fibonacci(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        \n        int prev = 0;\n        int curr = 1;\n        for (int i = 2; i <= n; i++) {\n            int next = prev + curr;\n            prev = curr;\n            curr = next;\n        }\n        return curr;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Fibonacci(0): \" + fibonacci(0));\n        System.out.println(\"Fibonacci(1): \" + fibonacci(1));\n        System.out.println(\"Fibonacci(6): \" + fibonacci(6));\n        System.out.println(\"Fibonacci(10): \" + fibonacci(10));\n    }\n}",
            "expectedOutput": "Fibonacci(0): 0\nFibonacci(1): 1\nFibonacci(6): 8\nFibonacci(10): 55",
            "hints": [
                "Handle base cases: fib(0) = 0, fib(1) = 1",
                "Use two variables to track previous two numbers",
                "Loop from 2 to n",
                "Calculate next number as sum of previous two",
                "Update the two tracking variables"
            ],
            "tags": [
                "medium",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "student-grade",
            "title": "Student Grade Manager",
            "difficulty": "medium",
            "category": "object-oriented",
            "description": "Design a Student class that manages academic performance data for individual students. The class should store a student's name and an array of integer grades representing their scores on various assessments. Implement a getAverage() method that calculates the mean of all grades by summing them and dividing by the count, ensuring you cast to double to preserve decimal precision. Additionally, create an isPassing() method that determines whether the student's average meets or exceeds a passing threshold of 60. This method should internally call getAverage() to avoid code duplication. Include appropriate constructors and getter methods. This exercise demonstrates practical object-oriented design, array manipulation, aggregate calculations, and the principle of method reusability through internal method calls.",
            "questionCode": "",
            "solutionCode": "public class Student {\n    private String name;\n    private int[] grades;\n    \n    public Student(String name, int[] grades) {\n        this.name = name;\n        this.grades = grades;\n    }\n    \n    public double getAverage() {\n        int sum = 0;\n        for (int grade : grades) {\n            sum += grade;\n        }\n        return (double) sum / grades.length;\n    }\n    \n    public boolean isPassing() {\n        return getAverage() >= 60;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public static void main(String[] args) {\n        Student s1 = new Student(\"Alice\", new int[]{85, 90, 78});\n        Student s2 = new Student(\"Bob\", new int[]{45, 55, 50});\n        \n        System.out.println(s1.getName() + \" average: \" + s1.getAverage());\n        System.out.println(s1.getName() + \" passing: \" + s1.isPassing());\n        System.out.println(s2.getName() + \" average: \" + s2.getAverage());\n        System.out.println(s2.getName() + \" passing: \" + s2.isPassing());\n    }\n}",
            "expectedOutput": "Alice average: 84.33333333333333\nAlice passing: true\nBob average: 50.0\nBob passing: false",
            "hints": [
                "For getAverage: sum all grades and divide by the number of grades",
                "Cast sum to double before division to get decimal result",
                "For isPassing: call getAverage() and check if it's >= 60",
                "Return the boolean result of the comparison"
            ],
            "tags": [
                "medium",
                "object-oriented"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "book-library",
            "title": "Book Library System",
            "difficulty": "hard",
            "category": "collections",
            "description": "Build a comprehensive Library management system using object-oriented principles and collections. First, create a Book class with private fields for title, author, and publication year, along with appropriate getters. Then, implement a Library class that maintains an ArrayList of Book objects and provides several search and analysis methods. The findByTitle method should perform a case-insensitive search and return the first matching book or null if not found. The getBooksByAuthor method should return a new ArrayList containing all books by a specified author. The countBooksAfterYear method should count how many books were published after a given year. This exercise combines multiple concepts: class design, collection management, search algorithms, filtering operations, and aggregate queries. It simulates a real-world application where you need to manage and query a collection of objects efficiently.",
            "questionCode": "",
            "solutionCode": "import java.util.ArrayList;\n\nclass Book {\n    private String title;\n    private String author;\n    private int year;\n    \n    public Book(String title, String author, int year) {\n        this.title = title;\n        this.author = author;\n        this.year = year;\n    }\n    \n    public String getTitle() { return title; }\n    public String getAuthor() { return author; }\n    public int getYear() { return year; }\n}\n\npublic class Library {\n    private ArrayList<Book> books = new ArrayList<>();\n    \n    public void addBook(Book book) {\n        books.add(book);\n    }\n    \n    public Book findByTitle(String title) {\n        for (Book book : books) {\n            if (book.getTitle().equalsIgnoreCase(title)) {\n                return book;\n            }\n        }\n        return null;\n    }\n    \n    public ArrayList<Book> getBooksByAuthor(String author) {\n        ArrayList<Book> result = new ArrayList<>();\n        for (Book book : books) {\n            if (book.getAuthor().equals(author)) {\n                result.add(book);\n            }\n        }\n        return result;\n    }\n    \n    public int countBooksAfterYear(int year) {\n        int count = 0;\n        for (Book book : books) {\n            if (book.getYear() > year) {\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    public static void main(String[] args) {\n        Library lib = new Library();\n        lib.addBook(new Book(\"1984\", \"George Orwell\", 1949));\n        lib.addBook(new Book(\"Animal Farm\", \"George Orwell\", 1945));\n        lib.addBook(new Book(\"Brave New World\", \"Aldous Huxley\", 1932));\n        \n        Book found = lib.findByTitle(\"1984\");\n        System.out.println(\"Found: \" + (found != null ? found.getTitle() : \"null\"));\n        \n        ArrayList<Book> orwellBooks = lib.getBooksByAuthor(\"George Orwell\");\n        System.out.println(\"Orwell books: \" + orwellBooks.size());\n        \n        System.out.println(\"Books after 1940: \" + lib.countBooksAfterYear(1940));\n    }\n}",
            "expectedOutput": "Found: 1984\nOrwell books: 2\nBooks after 1940: 2",
            "hints": [
                "For findByTitle: loop through books and use equalsIgnoreCase() for comparison",
                "Return the book immediately when found, or null after the loop",
                "For getBooksByAuthor: create a new ArrayList and add matching books",
                "For countBooksAfterYear: use a counter and increment when year condition is met"
            ],
            "tags": [
                "hard",
                "collections"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(n)"
        },
        {
            "id": "rectangle-class",
            "title": "Rectangle Class Implementation",
            "difficulty": "medium",
            "category": "object-oriented",
            "description": "Create a Rectangle class that models geometric rectangles with width and height dimensions. The class should encapsulate these dimensions as private double fields and provide a constructor to initialize them. Implement three key methods: getArea() should calculate and return the area using the formula width × height, getPerimeter() should calculate the perimeter using 2 × (width + height), and isSquare() should determine whether the rectangle is actually a square by checking if width equals height. This exercise demonstrates fundamental geometry calculations in an object-oriented context, proper encapsulation of data, and the implementation of derived properties (properties calculated from stored data rather than stored directly).",
            "questionCode": "",
            "solutionCode": "public class Rectangle {\n    private double width;\n    private double height;\n    \n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    public double getArea() {\n        return width * height;\n    }\n    \n    public double getPerimeter() {\n        return 2 * (width + height);\n    }\n    \n    public boolean isSquare() {\n        return width == height;\n    }\n    \n    public static void main(String[] args) {\n        Rectangle r1 = new Rectangle(5.0, 3.0);\n        Rectangle r2 = new Rectangle(4.0, 4.0);\n        \n        System.out.println(\"Rectangle 1 area: \" + r1.getArea());\n        System.out.println(\"Rectangle 1 perimeter: \" + r1.getPerimeter());\n        System.out.println(\"Rectangle 1 is square: \" + r1.isSquare());\n        System.out.println(\"Rectangle 2 is square: \" + r2.isSquare());\n    }\n}",
            "expectedOutput": "Rectangle 1 area: 15.0\nRectangle 1 perimeter: 16.0\nRectangle 1 is square: false\nRectangle 2 is square: true",
            "hints": [
                "Area formula: width * height",
                "Perimeter formula: 2 * (width + height)",
                "A rectangle is a square when width equals height",
                "Use == to compare the two dimensions"
            ],
            "tags": [
                "medium",
                "object-oriented"
            ],
            "bestCaseComplexity": "O(1)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "prime-checker",
            "title": "Prime Number Checker",
            "difficulty": "hard",
            "category": "algorithms",
            "description": "Implement an efficient algorithm to determine whether a given integer is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your solution should handle several special cases: numbers less than or equal to 1 are not prime, 2 is the only even prime number, and all other even numbers can be immediately rejected. For odd numbers, you only need to check for divisors up to the square root of n, because if n has a divisor greater than √n, it must also have a corresponding divisor less than √n. Furthermore, you only need to check odd divisors (3, 5, 7, ...) since you've already eliminated even numbers. This optimized approach significantly reduces the number of divisions required, achieving O(√n) time complexity instead of O(n).",
            "questionCode": "",
            "solutionCode": "public class MathUtils {\n    public static boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Is 2 prime: \" + isPrime(2));\n        System.out.println(\"Is 17 prime: \" + isPrime(17));\n        System.out.println(\"Is 20 prime: \" + isPrime(20));\n        System.out.println(\"Is 1 prime: \" + isPrime(1));\n    }\n}",
            "expectedOutput": "Is 2 prime: true\nIs 17 prime: true\nIs 20 prime: false\nIs 1 prime: false",
            "hints": [
                "Numbers less than or equal to 1 are not prime",
                "2 is the only even prime number",
                "Check divisibility only up to the square root of n",
                "Only check odd divisors after checking for 2",
                "If any divisor is found, the number is not prime"
            ],
            "tags": [
                "hard",
                "algorithms"
            ],
            "bestCaseComplexity": "O(√n)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "binary-search",
            "title": "Binary Search Implementation",
            "difficulty": "hard",
            "category": "algorithms",
            "description": "Implement the binary search algorithm, an efficient method for finding a target value within a sorted array. Binary search works by repeatedly dividing the search interval in half: compare the target value to the middle element of the array, and if they're not equal, eliminate the half in which the target cannot lie and continue searching the remaining half. This process continues until the target is found or the search space is exhausted. Your implementation should use an iterative approach with two pointers (left and right) that converge toward the target. Return the index of the target if found, or -1 if the target doesn't exist in the array. This algorithm achieves O(log n) time complexity, making it much more efficient than linear search for large sorted datasets. Understanding binary search is fundamental to computer science and forms the basis for many other algorithms.",
            "questionCode": "",
            "solutionCode": "public class SearchUtils {\n    public static int binarySearch(int[] arr, int target) {\n        int left = 0;\n        int right = arr.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            }\n            \n            if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};\n        \n        System.out.println(\"Index of 7: \" + binarySearch(sortedArray, 7));\n        System.out.println(\"Index of 15: \" + binarySearch(sortedArray, 15));\n        System.out.println(\"Index of 1: \" + binarySearch(sortedArray, 1));\n        System.out.println(\"Index of 8: \" + binarySearch(sortedArray, 8));\n    }\n}",
            "expectedOutput": "Index of 7: 3\nIndex of 15: 7\nIndex of 1: 0\nIndex of 8: -1",
            "hints": [
                "Initialize left pointer to 0 and right pointer to arr.length - 1",
                "Calculate middle index as left + (right - left) / 2 to avoid overflow",
                "If middle element equals target, return the index",
                "If target is greater, search the right half (left = mid + 1)",
                "If target is smaller, search the left half (right = mid - 1)",
                "Return -1 if the loop completes without finding the target"
            ],
            "tags": [
                "hard",
                "algorithms"
            ],
            "bestCaseComplexity": "O(log n)",
            "worstCaseComplexity": "O(log n)"
        },
        {
            "id": "bubble-sort",
            "title": "Bubble Sort Implementation",
            "difficulty": "medium",
            "category": "algorithms",
            "description": "Implement the bubble sort algorithm, a simple sorting technique that repeatedly steps through the array, compares adjacent elements, and swaps them if they're in the wrong order. The algorithm gets its name from the way smaller elements 'bubble' to the top of the array. Your implementation should use nested loops: the outer loop runs n-1 times (where n is the array length), and the inner loop performs the comparisons and swaps for each pass. After each complete pass, the largest unsorted element is guaranteed to be in its final position, so you can optimize by reducing the inner loop's range with each iteration. Include an optimization flag to detect if no swaps occurred during a pass, indicating the array is already sorted and allowing early termination. This implementation should sort the array in-place, modifying the original array rather than creating a new one.",
            "questionCode": "",
            "solutionCode": "public class SortUtils {\n    public static void bubbleSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            boolean swapped = false;\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    // Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n            // If no swaps occurred, array is sorted\n            if (!swapped) {\n                break;\n            }\n        }\n    }\n    \n    public static void printArray(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i]);\n            if (i < arr.length - 1) System.out.print(\" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        int[] arr1 = {64, 34, 25, 12, 22, 11, 90};\n        int[] arr2 = {5, 1, 4, 2, 8};\n        \n        System.out.print(\"Original array 1: \");\n        printArray(arr1);\n        bubbleSort(arr1);\n        System.out.print(\"Sorted array 1: \");\n        printArray(arr1);\n        \n        System.out.print(\"Original array 2: \");\n        printArray(arr2);\n        bubbleSort(arr2);\n        System.out.print(\"Sorted array 2: \");\n        printArray(arr2);\n    }\n}",
            "expectedOutput": "Original array 1: 64 34 25 12 22 11 90\nSorted array 1: 11 12 22 25 34 64 90\nOriginal array 2: 5 1 4 2 8\nSorted array 2: 1 2 4 5 8",
            "hints": [
                "Use nested loops: outer loop runs n-1 times",
                "Inner loop compares adjacent elements",
                "Swap elements if they're in wrong order (arr[j] > arr[j+1])",
                "Use a temporary variable for swapping",
                "Optimize by reducing inner loop range: n - i - 1",
                "Add a flag to detect if array is already sorted"
            ],
            "tags": [
                "medium",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n)",
            "worstCaseComplexity": "O(n²)"
        },
        {
            "id": "bank-account",
            "title": "Bank Account Management System",
            "difficulty": "hard",
            "category": "object-oriented",
            "description": "Design a comprehensive BankAccount class that simulates real-world banking operations with proper encapsulation and validation. The class should maintain private fields for account number (String), account holder name (String), and balance (double). Implement a constructor that initializes all fields with an initial balance. Create methods for common banking operations: deposit() should add money to the account only if the amount is positive, withdraw() should deduct money only if the amount is positive and doesn't exceed the current balance (returning true for successful withdrawal, false otherwise), and getBalance() should return the current balance. Add a transfer() method that moves money from this account to another BankAccount object, ensuring all validation rules are followed. Include a toString() method that formats account information clearly. This exercise demonstrates encapsulation, validation logic, object interaction, and the modeling of real-world business rules in code.",
            "questionCode": "",
            "solutionCode": "public class BankAccount {\n    private String accountNumber;\n    private String holderName;\n    private double balance;\n    \n    public BankAccount(String accountNumber, String holderName, double initialBalance) {\n        this.accountNumber = accountNumber;\n        this.holderName = holderName;\n        this.balance = initialBalance;\n    }\n    \n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n    \n    public boolean withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n    \n    public boolean transfer(BankAccount recipient, double amount) {\n        if (withdraw(amount)) {\n            recipient.deposit(amount);\n            return true;\n        }\n        return false;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public String getAccountNumber() {\n        return accountNumber;\n    }\n    \n    public String getHolderName() {\n        return holderName;\n    }\n    \n    @Override\n    public String toString() {\n        return \"Account[\" + accountNumber + \", \" + holderName + \", Balance: $\" + balance + \"]\";\n    }\n    \n    public static void main(String[] args) {\n        BankAccount acc1 = new BankAccount(\"12345\", \"Alice\", 1000.0);\n        BankAccount acc2 = new BankAccount(\"67890\", \"Bob\", 500.0);\n        \n        System.out.println(\"Initial: \" + acc1);\n        System.out.println(\"Initial: \" + acc2);\n        \n        acc1.deposit(200);\n        System.out.println(\"After deposit: \" + acc1.getBalance());\n        \n        boolean success = acc1.withdraw(300);\n        System.out.println(\"Withdrawal success: \" + success);\n        System.out.println(\"After withdrawal: \" + acc1.getBalance());\n        \n        boolean transferSuccess = acc1.transfer(acc2, 400);\n        System.out.println(\"Transfer success: \" + transferSuccess);\n        System.out.println(\"Final: \" + acc1);\n        System.out.println(\"Final: \" + acc2);\n    }\n}",
            "expectedOutput": "Initial: Account[12345, Alice, Balance: $1000.0]\nInitial: Account[67890, Bob, Balance: $500.0]\nAfter deposit: 1200.0\nWithdrawal success: true\nAfter withdrawal: 900.0\nTransfer success: true\nFinal: Account[12345, Alice, Balance: $500.0]\nFinal: Account[67890, Bob, Balance: $900.0]",
            "hints": [
                "Validate that deposit amounts are positive",
                "For withdraw, check both that amount is positive and doesn't exceed balance",
                "Return boolean from withdraw to indicate success/failure",
                "Implement transfer by calling withdraw on source and deposit on recipient",
                "Use the 'this' keyword to refer to the current object",
                "Format toString output clearly with account details"
            ],
            "tags": [
                "hard",
                "object-oriented"
            ],
            "bestCaseComplexity": "O(1)",
            "worstCaseComplexity": "O(1)"
        },
        {
            "id": "selection-sort",
            "title": "Selection Sort Algorithm",
            "difficulty": "medium",
            "category": "algorithms",
            "description": "Implement the selection sort algorithm, which sorts an array by repeatedly finding the minimum element from the unsorted portion and moving it to the beginning. The algorithm divides the array into two parts: a sorted portion at the beginning and an unsorted portion at the end. In each iteration, it scans the unsorted portion to find the smallest element, then swaps it with the first element of the unsorted portion. Your implementation should use an outer loop to track the boundary between sorted and unsorted portions, and an inner loop to find the minimum element in the unsorted portion. The algorithm should sort the array in-place (without creating a new array) in ascending order. Selection sort always performs O(n²) comparisons regardless of the initial order of elements, making it inefficient for large datasets, but it has the advantage of making at most n swaps (one per iteration), which can be beneficial when swaps are expensive operations.",
            "questionCode": "",
            "solutionCode": "public class SortUtils {\n    public static void selectionSort(int[] arr) {\n        int n = arr.length;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            \n            // Find minimum element in unsorted portion\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] < arr[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            \n            // Swap minimum element with first element of unsorted portion\n            int temp = arr[minIndex];\n            arr[minIndex] = arr[i];\n            arr[i] = temp;\n        }\n    }\n    \n    public static void printArray(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i]);\n            if (i < arr.length - 1) System.out.print(\" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        int[] arr1 = {64, 25, 12, 22, 11};\n        int[] arr2 = {29, 10, 14, 37, 13};\n        \n        System.out.print(\"Original array 1: \");\n        printArray(arr1);\n        selectionSort(arr1);\n        System.out.print(\"Sorted array 1: \");\n        printArray(arr1);\n        \n        System.out.print(\"Original array 2: \");\n        printArray(arr2);\n        selectionSort(arr2);\n        System.out.print(\"Sorted array 2: \");\n        printArray(arr2);\n    }\n}",
            "expectedOutput": "Original array 1: 64 25 12 22 11\nSorted array 1: 11 12 22 25 64\nOriginal array 2: 29 10 14 37 13\nSorted array 2: 10 13 14 29 37",
            "hints": [
                "Outer loop runs from 0 to n-2 (marks the boundary between sorted and unsorted)",
                "Initialize minIndex to current position at start of each iteration",
                "Inner loop finds the index of minimum element in unsorted portion",
                "After finding minimum, swap it with the element at position i",
                "Use a temporary variable for swapping",
                "The sorted portion grows by one element in each iteration"
            ],
            "tags": [
                "medium",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n²)",
            "worstCaseComplexity": "O(n²)"
        },
        {
            "id": "matrix-transpose",
            "title": "Matrix Transpose Operation",
            "difficulty": "medium",
            "category": "algorithms",
            "description": "Implement a method that calculates the transpose of a matrix. The transpose of a matrix is obtained by flipping it over its diagonal, which means switching the row and column indices of each element. For a matrix A with dimensions m×n, the transpose will be a matrix with dimensions n×m, where the element at position (i,j) in the original matrix appears at position (j,i) in the transposed matrix. Your method should accept a 2D integer array representing the original matrix and return a new 2D array containing the transposed matrix. For example, transposing [[1,2,3],[4,5,6]] produces [[1,4],[2,5],[3,6]]. This operation is fundamental in linear algebra and has applications in graphics, data transformation, and matrix mathematics. Your implementation should correctly handle both square matrices (where rows equal columns) and rectangular matrices.",
            "questionCode": "",
            "solutionCode": "public class MatrixUtils {\n    public static int[][] transpose(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        int[][] result = new int[cols][rows];\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                result[j][i] = matrix[i][j];\n            }\n        }\n        \n        return result;\n    }\n    \n    public static void printMatrix(int[][] matrix) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                System.out.print(matrix[i][j]);\n                if (j < matrix[i].length - 1) System.out.print(\" \");\n            }\n            System.out.println();\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}};\n        int[][] matrix2 = {{1, 2}, {3, 4}, {5, 6}};\n        \n        System.out.println(\"Original matrix 1:\");\n        printMatrix(matrix1);\n        System.out.println(\"Transposed matrix 1:\");\n        printMatrix(transpose(matrix1));\n        \n        System.out.println(\"Original matrix 2:\");\n        printMatrix(matrix2);\n        System.out.println(\"Transposed matrix 2:\");\n        printMatrix(transpose(matrix2));\n    }\n}",
            "expectedOutput": "Original matrix 1:\n1 2 3\n4 5 6\nTransposed matrix 1:\n1 4\n2 5\n3 6\nOriginal matrix 2:\n1 2\n3 4\n5 6\nTransposed matrix 2:\n1 3 5\n2 4 6",
            "hints": [
                "Get dimensions: rows = matrix.length, cols = matrix[0].length",
                "Create result matrix with swapped dimensions: new int[cols][rows]",
                "Use nested loops to iterate through original matrix",
                "Copy element from matrix[i][j] to result[j][i]",
                "Return the result matrix"
            ],
            "tags": [
                "medium",
                "algorithms"
            ],
            "bestCaseComplexity": "O(m*n)",
            "worstCaseComplexity": "O(m*n)"
        },
        {
            "id": "anagram-checker",
            "title": "Anagram Detection",
            "difficulty": "medium",
            "category": "algorithms",
            "description": "Create a method that determines whether two strings are anagrams of each other. Two strings are anagrams if they contain exactly the same characters with the same frequencies, but possibly in a different order. For example, 'listen' and 'silent' are anagrams. Your implementation should first check if the strings have the same length (if not, they cannot be anagrams). Then, convert both strings to character arrays, sort them, and compare the sorted arrays for equality. This approach works because if two strings are anagrams, their sorted character sequences will be identical. Make the comparison case-insensitive by converting both strings to lowercase before processing. This problem demonstrates string manipulation, array operations, and the application of sorting to solve a practical text processing problem.",
            "questionCode": "",
            "solutionCode": "import java.util.Arrays;\n\npublic class StringUtils {\n    public static boolean areAnagrams(String str1, String str2) {\n        // Remove spaces and convert to lowercase\n        str1 = str1.replaceAll(\"\\\\s\", \"\").toLowerCase();\n        str2 = str2.replaceAll(\"\\\\s\", \"\").toLowerCase();\n        \n        // If lengths differ, they can't be anagrams\n        if (str1.length() != str2.length()) {\n            return false;\n        }\n        \n        // Convert to char arrays and sort\n        char[] arr1 = str1.toCharArray();\n        char[] arr2 = str2.toCharArray();\n        \n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n        \n        // Compare sorted arrays\n        return Arrays.equals(arr1, arr2);\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"listen and silent: \" + areAnagrams(\"listen\", \"silent\"));\n        System.out.println(\"hello and world: \" + areAnagrams(\"hello\", \"world\"));\n        System.out.println(\"The Morse Code and Here come dots: \" + \n                          areAnagrams(\"The Morse Code\", \"Here come dots\"));\n        System.out.println(\"abc and abcd: \" + areAnagrams(\"abc\", \"abcd\"));\n    }\n}",
            "expectedOutput": "listen and silent: true\nhello and world: false\nThe Morse Code and Here come dots: true\nabc and abcd: false",
            "hints": [
                "Remove spaces using replaceAll and convert to lowercase",
                "Check if lengths are equal first (quick rejection)",
                "Convert strings to character arrays using toCharArray()",
                "Sort both arrays using Arrays.sort()",
                "Compare sorted arrays using Arrays.equals()",
                "Return the result of the comparison"
            ],
            "tags": [
                "medium",
                "algorithms"
            ],
            "bestCaseComplexity": "O(n log n)",
            "worstCaseComplexity": "O(n log n)"
        }
    ]
}
